# CSES 1633 — Dice Combinations
 題目連結  
https://cses.fi/problemset/task/1633/

---

##  題目說明

給定一個整數 `n`，每次可以擲一顆骰子，點數範圍為 **1 到 6**。  
請計算 **所有點數總和剛好等於 `n` 的不同組合數量**。

＃ 結果可能非常大，請將答案對 **`10^9 + 7`** 取模。

---

##  解題思路（Dynamic Programming）

###  _1._  狀態定義

令： $dp[i] =$ 點數總和為 $i$ 的所有合法組合數

---

###  _2._ 狀態轉移

每一次擲骰子可能出現 1～6 點，因此： $dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp[i-6]$

---

### _3._ 邊界與初始化

- 若 `i - k < 0`，該項不可計算
- 初始狀態： $dp[0] = 1$

代表「不擲骰子」也是一種合法方式

---

### _4._ 為什麼要取模（mod）

組合數會隨 `n` 指數成長，若不取模會造成 **整數溢位（overflow）**。  
因此每一步都必須對 `10^9 + 7` 取模。

---

##  演算法流程

1. 使用一維 DP 陣列 `dp`
2. 外層枚舉目前點數總和 `i`
3. 內層枚舉骰子點數 `k = 1 ~ 6`
4. 當 `i - k >= 0` 時才進行狀態轉移
5. 每一步皆進行取模運算

---

## 🧾 C++ 參考實作

```cpp
#include <iostream>
using namespace std;

int main()
{
    long long n;
    cin >> n;

    int dp[n + 1];
    for (int i = 0; i <= n; i++) dp[i] = 0;

    dp[0] = 1;

    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= 6; k++)
        {
            if (i - k >= 0)
            {
                dp[i] = (dp[i] + dp[i - k]) % 1000000007;
            }
        }
    }

    cout << dp[n];
}
